同步:
环境初始化：同步标志置为True， 请求标志置为True，响应数量置为0,节点签名置为[]
prepare由于一个节点只会发出一个块请求
格式：本地地址 + 目标地址
接收到prepare请求之后，将新的块解析出来存放在内存里面，然后和交易一样，将原来请求下发给注册节点，
然后将自己的结果返回给目标节点，不同的是判断方式，如果已经有同步的，返回reject，没有返回permit
响应格式：本地地址 + 目标地址 + 结果 + 签名
响应处理和交易类似，唯一区别是验证通过发送add

add 格式：本地地址 + hash + 新的块
响应add请求：添加块，重置原来的block_new，标志重置。转发给邻近节点
note: 需要判断交易，多删少增（同步块交易多于block_new，在缓存池中删掉多余的，少于的，将少的返回缓存池）

add完成后发起commit给目标地址，
目标地址接收到之后统计数量，数量达到后更改状态


交易：
接收交易：数据 + gas消耗（暂定为0)
广播：pre-prepare prepare commit

初始化pre-prepare: 请求标志（默认为True，达到要求变为False） 响应数量（默认为0) 节点签名。默认为[]

pre-prepare 格式：本节点地址（防止节点将元信息转发回来）+ 目标地址（转发结果有关） + 交易hash（获取交易有关）
 + 交易（所有节点预存，防止发起节点坏死的情况）

接收到pre-prepare： 添加交易。此处验证结果为permit,表示已经准备完毕，可以进行。同是把原来交易情况下发给注册节点
需要注意的是，request_address不需要转发prepare
响应格式：本节点地址 + 目标地址 + 结果 + 交易hash（给目标地址的交易标志） + 本节点签名sign

pre_prepare响应处理：
如果是目标节点且request标志为True：将签名添加到SignMap，将响应+1,响应结果记录，然后判断响应结果，如果结果达到验证通过需求，
则更新request标志为False，且发送prepare请求,同时初始化prepare环境。如果交易全部返回清除标志。如果最后验证还未达到，则认为交易失败，
如果不是则转发.

prepare 格式： 本节点地址 + 目标地址 + 交易hash
接收到prepare请求之后,处理和pre-prepare一样
响应格式和pre-prepare一样
响应处理也类似，只是通过后发送commit

commit 格式:本节点地址 + 交易hash
接收到commit后，不需要返回东西，需要传递commit请求和将自己交易更改信息并提交到已同步列表中



添加账户:
	用户发起连接请求，根据私钥来比对公钥，有则返回用户信息（后面会有客户端，能够进行账户操作）
用户加密解密：
加密解密：使用python3的 py crypto生成rsa公钥私钥
判断用户：使用hash加公钥私钥验证
http:
用户请求需要参数：用户名，数据，路径
接收请求后.后台生成账户数据结构，然后生成公钥，并生成一个用户文件，里面包含私钥和hash值。
唯一指定用户合法性，然后将账户广播，不用接收返回值。
广播格式：本地地址 + 用户hash + 用户（json解析过的）
接收到广播之后，直接添加和转发即可

用户连接网络：
提供[地址],hash


程序备注点：
	块的解析：块内部不会去判断解析格式，所以添加数据时需要自己将不能更改的格式先转化在添加
	块的加载：返回的格式需要自己进行一次加工，将交易和账户手动转化。
	节点计算方式：本身节点不加入节点number，也不加入node，仅用于别的节点注册的时候反馈注册。
	加密解密算法，获得密钥的时候需要手动加工，因为json不能解析字节数组

节点注册流程：
	A 注册到 B 上：
	A 发register到A上，A 接收到后将自己的信息发送到 B 上
	B 接收到之后将A的信息加到自己这边，然后将自己信息发给A。同时将历史文件发给A
	A 接收到之后将B的信息加到自己这边。

用户的余额计算：
    交易时需要记录gas（最后一次消耗）来源，格式为（index：块的索引，‘use_gas' :消耗的gas）。
    计算消耗的： 查询余额函数返回 （是否有交易，最后一个块的索引，gas消耗，余额）
    查询余额算法：在时间范围内，查看最后一次交易，没有进行下一步。找出提供gas的最后一个块，
    余额=那个块剩余的 + 以后获得的。
    不再范围内，则直接计算范围内的总和。
    在获取的时候计算（包括确认还没添加的）

投票机制：使用定时器来做（threading.timer）。每一次收到块同步之后，同步完启用投票定时器
         当定时器达到时间时，发起选举请求（每个都发起），不需要接收返回值。
         每个节点接收到第一个选举请求后，同意然后将结果广播给区块链。其他的请求直接忽略掉

